package pentester

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"strconv"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/yourusername/cyverApiCli/cmd/shared"
	"github.com/yourusername/cyverApiCli/internal/api/versions/v2_2"
	"github.com/yourusername/cyverApiCli/internal/errors"
)

// Findings command group
var findingsCmd = &cobra.Command{
	Use:   "findings",
	Short: "Manage findings operations",
	Long:  `Manage findings information and operations for pentesters.`,
}

// List findings command
var listFindingsCmd = &cobra.Command{
	Use:   "list",
	Short: "List findings (pentester view)",
	Long:  `Retrieve a paginated list of findings with optional filtering using pentester operations.`,
	Run: func(cmd *cobra.Command, args []string) {
		clientVersion := shared.GetVersionedApiClient()
		if clientVersion == nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeConfigInvalid, "failed to initialize API client", nil))
			return
		}

		// Type switch to handle different client versions
		switch client := clientVersion.(type) {
		case *v2_2.Client:
			if client.PentesterOps == nil {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, "PentesterOps is nil for v2.2 client", nil))
				return
			}

			// Get flag values with defaults
			projectID, _ := cmd.Flags().GetString("project-id")
			findingType, _ := cmd.Flags().GetString("type")
			status, _ := cmd.Flags().GetString("status")
			severityList, _ := cmd.Flags().GetString("severity-list")
			vulnerabilityTypeList, _ := cmd.Flags().GetString("vulnerability-type-list")
			idList, _ := cmd.Flags().GetString("id-list")
			assetIdList, _ := cmd.Flags().GetString("asset-id-list")
			maxResults, _ := cmd.Flags().GetInt("max-results")
			skipCount, _ := cmd.Flags().GetInt("skip-count")

			pagedResult, err := client.PentesterOps.ApiV22PentesterFindingsGet(projectID, findingType, status, severityList, vulnerabilityTypeList, idList, assetIdList, maxResults, skipCount)
			if err != nil {
				shared.HandleError(cmd, err)
				return
			}

			// Get the output format option and validate it
			outputFormat, _ := cmd.Flags().GetString("output")

			// Validate output format
			validFormats := []string{"json", "short", "table", "custom"}
			isValidFormat := false
			for _, format := range validFormats {
				if outputFormat == format {
					isValidFormat = true
					break
				}
			}

			if !isValidFormat {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed,
					fmt.Sprintf("Invalid output format '%s'. Valid options are: %s", outputFormat, strings.Join(validFormats, ", ")), nil))
				return
			}

			// Use the output format-specific function
			switch outputFormat {
			case "json":
				if err := shared.PrintJSONResponse(pagedResult); err != nil {
					shared.HandleError(cmd, err)
				}
			case "short":
				if err := shared.PrintSimpleFindingsList(pagedResult); err != nil {
					shared.LogError("Error printing short response", "error", err)
				}
			case "table":
				if err := shared.PrintSimpleFindingsTable(pagedResult); err != nil {
					shared.HandleError(cmd, err)
				}
			case "custom":
				maxColumns, _ := cmd.Flags().GetInt("max-columns")
				if maxColumns <= 0 {
					maxColumns = 4 // Default to 4 columns
				}
				if err := shared.PrintCustomTable(pagedResult, maxColumns); err != nil {
					shared.HandleError(cmd, err)
				}
			}

		default:
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, fmt.Sprintf("unsupported client type: %T", clientVersion), nil))
			return
		}
	},
}

// Get finding by ID command
var getFindingCmd = &cobra.Command{
	Use:   "get [finding-id]",
	Short: "Get finding by ID (pentester view)",
	Long:  `Retrieve detailed information about a specific finding using pentester operations.`,
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		findingID := args[0]

		clientVersion := shared.GetVersionedApiClient()
		if clientVersion == nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeConfigInvalid, "failed to initialize API client", nil))
			return
		}

		// Type switch to handle different client versions
		switch client := clientVersion.(type) {
		case *v2_2.Client:
			if client.PentesterOps == nil {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, "PentesterOps is nil for v2.2 client", nil))
				return
			}

			// Get flag value with default
			includeEvidence, _ := cmd.Flags().GetBool("include-evidence")

			response, err := client.PentesterOps.ApiV22PentesterFindingsByIdGet(findingID, includeEvidence)
			if err != nil {
				shared.LogError("Error: failed to get finding", "error", err)
				return
			}

			// Get the output format option
			outputFormat, _ := cmd.Flags().GetString("output")

			// Validate output format
			validFormats := []string{"json", "table", "custom"}
			isValidFormat := false
			for _, format := range validFormats {
				if outputFormat == format {
					isValidFormat = true
					break
				}
			}

			if !isValidFormat {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed,
					fmt.Sprintf("Invalid output format '%s'. Valid options are: %s", outputFormat, strings.Join(validFormats, ", ")), nil))
				return
			}

			if err != nil {
				shared.LogError("Error: failed to get finding", "error", err)
				return
			}

			// Use the output format-specific function
			switch outputFormat {
			case "json":
				if err := shared.PrintJSONResponse(response); err != nil {
					shared.HandleError(cmd, err)
				}
			case "table":
				if err := shared.PrintFindingTable(response); err != nil {
					shared.HandleError(cmd, err)
				}
			case "custom":
				maxColumns, _ := cmd.Flags().GetInt("max-columns")
				if maxColumns <= 0 {
					maxColumns = 4 // Default to 4 columns
				}
				if err := shared.PrintCustomTable(response, maxColumns); err != nil {
					shared.HandleError(cmd, err)
				}
			}

		default:
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, fmt.Sprintf("unsupported client type: %T", clientVersion), nil))
			return
		}
	},
}

// Create finding command
var createFindingCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new finding (pentester view)",
	Long:  `Create a new finding with the specified details using pentester operations.`,
	Run: func(cmd *cobra.Command, args []string) {
		projectID, _ := cmd.Flags().GetString("project-id")
		triggerEvents, _ := cmd.Flags().GetBool("trigger-events")

		if projectID == "" {
			shared.LogError("Error: project-id is required")
			return
		}

		// Get finding data from flags
		title, _ := cmd.Flags().GetString("title")
		description, _ := cmd.Flags().GetString("description")
		severity, _ := cmd.Flags().GetString("severity")
		status, _ := cmd.Flags().GetString("status")
		findingType, _ := cmd.Flags().GetString("type")

		if title == "" {
			shared.LogError("Error: title is required")
			return
		}

		// Set default status to "draft" if not provided
		if status == "" {
			status = "draft"
		}

		// Validate finding type if provided
		if findingType != "" {
			validTypes := []string{"Vulnerability", "Observation"}
			isValidType := false
			for _, validType := range validTypes {
				if findingType == validType {
					isValidType = true
					break
				}
			}
			if !isValidType {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed,
					fmt.Sprintf("Invalid finding type '%s'. Valid options are: %s", findingType, strings.Join(validTypes, ", ")), nil))
				return
			}
		}

		// Validate severity if provided
		if severity != "" {
			validSeverities := []string{"critical", "high", "medium", "low", "info"}
			isValidSeverity := false
			severityLower := strings.ToLower(severity)
			for _, validSeverity := range validSeverities {
				if severityLower == validSeverity {
					isValidSeverity = true
					break
				}
			}
			if !isValidSeverity {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed,
					fmt.Sprintf("Invalid severity '%s'. Valid options are: %s", severity, strings.Join(validSeverities, ", ")), nil))
				return
			}
		}

		// Create finding request body
		// Note: projectId and triggerEvents are query parameters, not in the body
		findingBody := map[string]interface{}{
			"name":        title, // API expects "name" not "title"
			"description": description,
		}

		// Add severity if provided (convert string to enum value)
		// Severity scale is reversed and starts at 0: Info=0, Low=1, Medium=2, High=3, Critical=4
		if severity != "" {
			var severityValue int32
			severityLower := strings.ToLower(severity)
			switch severityLower {
			case "info":
				severityValue = 0 // FindingSeverityEnum_Info (lowest severity)
			case "low":
				severityValue = 1 // FindingSeverityEnum_Low
			case "medium":
				severityValue = 2 // FindingSeverityEnum_Medium
			case "high":
				severityValue = 3 // FindingSeverityEnum_High
			case "critical":
				severityValue = 4 // FindingSeverityEnum_Critical (highest severity)
			}
			findingBody["severity"] = severityValue
		}

		// Add status (convert string to enum value, default to draft)
		var statusValue int32
		statusLower := strings.ToLower(status)
		switch statusLower {
		case "draft":
			statusValue = 1 // FindingStatusEnum_Draft
		case "pendingfix", "pending-fix":
			statusValue = 2 // FindingStatusEnum_PendingFix
		case "fixed":
			statusValue = 3 // FindingStatusEnum_Fixed
		case "readyretest", "ready-retest":
			statusValue = 4 // FindingStatusEnum_ReadyRetest
		case "accepted":
			statusValue = 5 // FindingStatusEnum_Accepted
		case "toreview", "to-review":
			statusValue = 6 // FindingStatusEnum_ToReview
		case "reviewed":
			statusValue = 7 // FindingStatusEnum_Reviewed
		case "mitigated":
			statusValue = 8 // FindingStatusEnum_Mitigated
		case "partialfix", "partial-fix":
			statusValue = 9 // FindingStatusEnum_PartialFix
		case "falsepositive", "false-positive":
			statusValue = 10 // FindingStatusEnum_FalsePositive
		case "raised":
			statusValue = 11 // FindingStatusEnum_Raised
		case "reopen", "re-open":
			statusValue = 12 // FindingStatusEnum_ReOpen
		case "acknowledged":
			statusValue = 13 // FindingStatusEnum_Acknowledged
		case "identified":
			statusValue = 14 // FindingStatusEnum_Identified
		default:
			// Default to draft if status is not recognized
			statusValue = 1 // FindingStatusEnum_Draft
		}
		findingBody["status"] = statusValue

		// Add type field if provided (convert string to enum value)
		if findingType != "" {
			var typeValue int32
			switch findingType {
			case "Vulnerability":
				typeValue = 1 // FindingTypeEnum_Vulnerability
			case "Observation":
				typeValue = 4 // FindingTypeEnum_Observation
			}
			findingBody["type"] = typeValue
		}

		clientVersion := shared.GetVersionedApiClient()
		if clientVersion == nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeConfigInvalid, "failed to initialize API client", nil))
			return
		}

		// Type switch to handle different client versions
		switch client := clientVersion.(type) {
		case *v2_2.Client:
			if client.PentesterOps == nil {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, "PentesterOps is nil for v2.2 client", nil))
				return
			}

			response, err := client.PentesterOps.ApiV22PentesterFindingsPost(projectID, triggerEvents, findingBody)
			if err != nil {
				shared.LogError("Error: failed to create finding", "error", err)
				return
			}

			fmt.Printf("Successfully created finding\n")

			// Extract finding ID from response and print URL
			if response != nil {
				// Parse the interface{} response to extract the result field
				responseBytes, err := json.Marshal(*response)
				if err == nil {
					var guidResponse v2_2.GuidAjaxResponse
					if err := json.Unmarshal(responseBytes, &guidResponse); err == nil {
						if guidResponse.Result != nil && *guidResponse.Result != "" {
							// Get base URL from config
							baseURL := viper.GetString("api.base_url")
							if baseURL != "" {
								// Parse base URL to extract host
								parsedURL, err := url.Parse(baseURL)
								if err == nil {
									// Convert API URL to app URL (e.g., api.cyver.io -> app.cyver.io or just use the domain)
									host := parsedURL.Host
									// Replace "api." with "app." if present, otherwise use the host as-is
									if strings.HasPrefix(host, "api.") {
										host = strings.Replace(host, "api.", "app.", 1)
									}
									// Construct the finding URL
									findingURL := fmt.Sprintf("%s://%s/App/Projects/Details/%s/Finding/%s",
										parsedURL.Scheme, host, projectID, *guidResponse.Result)
									fmt.Printf("Finding URL: %s\n", findingURL)
								}
							}
						}
					}
				}
			}

		default:
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, fmt.Sprintf("unsupported client type: %T", clientVersion), nil))
			return
		}
	},
}

// Update finding command
var updateFindingCmd = &cobra.Command{
	Use:   "update [finding-id]",
	Short: "Update a finding (pentester view)",
	Long:  `Update an existing finding using pentester operations.`,
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		findingID := args[0]
		triggerEvents, _ := cmd.Flags().GetBool("trigger-events")

		// Get update data from flags
		title, _ := cmd.Flags().GetString("title")
		description, _ := cmd.Flags().GetString("description")
		severity, _ := cmd.Flags().GetString("severity")
		status, _ := cmd.Flags().GetString("status")

		// Create update request body
		updateBody := map[string]interface{}{}
		if title != "" {
			updateBody["name"] = title // API expects "name" not "title"
		}
		if description != "" {
			updateBody["description"] = description
		}
		if severity != "" {
			updateBody["severity"] = severity
		}
		if status != "" {
			updateBody["status"] = status
		}

		clientVersion := shared.GetVersionedApiClient()
		if clientVersion == nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeConfigInvalid, "failed to initialize API client", nil))
			return
		}

		// Type switch to handle different client versions
		switch client := clientVersion.(type) {
		case *v2_2.Client:
			if client.PentesterOps == nil {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, "PentesterOps is nil for v2.2 client", nil))
				return
			}

			_, err := client.PentesterOps.ApiV22PentesterFindingsByIdPut(findingID, triggerEvents, updateBody)
			if err != nil {
				shared.LogError("Error: failed to update finding", "error", err)
				return
			}

			fmt.Printf("Successfully updated finding %s\n", findingID)

		default:
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, fmt.Sprintf("unsupported client type: %T", clientVersion), nil))
			return
		}
	},
}

// Evidence command group (attached to findings)
var evidenceCmd = &cobra.Command{
	Use:   "evidence",
	Short: "Manage evidence attached to findings",
	Long:  `Create or manage evidence instances attached to a finding.`,
}

// Create evidence command
var createEvidenceCmd = &cobra.Command{
	Use:   "create",
	Short: "Create evidence attached to a finding (pentester view)",
	Long:  `Create an evidence instance attached to a finding using the CreateOrEditFindingInstance API.`,
	Run: func(cmd *cobra.Command, args []string) {
		findingID, _ := cmd.Flags().GetString("finding-id")
		if findingID == "" {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, "finding-id is required", nil))
			return
		}

		title, _ := cmd.Flags().GetString("title")
		if title == "" {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, "title is required", nil))
			return
		}

		visibleInReport, _ := cmd.Flags().GetBool("visible-in-report")

		// Build body with PascalCase keys to match CreateOrEditFindingInstance API
		body := map[string]interface{}{
			"Guid":              "00000000-0000-0000-0000-000000000000", // new evidence
			"Title":             title,
			"Asset":             getStringFlag(cmd, "asset"),
			"Location":          getStringFlag(cmd, "location"),
			"Version":           getStringFlag(cmd, "version"),
			"Ip":                getStringFlag(cmd, "ip"),
			"Hostname":          getStringFlag(cmd, "hostname"),
			"Port":              getStringFlag(cmd, "port"),
			"Protocol":          getStringFlag(cmd, "protocol"),
			"IssueDetails":      getStringFlag(cmd, "issue-details"),
			"Reproduce":         getStringFlag(cmd, "reproduce"),
			"Evidence":          getStringFlag(cmd, "evidence"),
			"IsVisibleInReport": strings.ToLower(fmt.Sprintf("%t", visibleInReport)),
			"EvidenceFiles":     []interface{}{},
			"NewEvidenceFiles":  []interface{}{},
		}

		clientVersion := shared.GetVersionedApiClient()
		if clientVersion == nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeConfigInvalid, "failed to initialize API client", nil))
			return
		}

		switch client := clientVersion.(type) {
		case *v2_2.Client:
			if client.PentesterOps == nil {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, "PentesterOps is nil for v2.2 client", nil))
				return
			}

			_, err := client.PentesterOps.ApiV22PentesterFindingEvidencePost(findingID, body)
			if err != nil {
				shared.HandleError(cmd, err)
				return
			}

			fmt.Printf("Successfully created evidence for finding %s\n", findingID)
		default:
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, fmt.Sprintf("unsupported client type: %T", clientVersion), nil))
			return
		}
	},
}

// getStringFlag returns the string value of a flag, or "" if not set.
func getStringFlag(cmd *cobra.Command, name string) string {
	s, _ := cmd.Flags().GetString(name)
	return s
}

// Import evidence command
var importEvidenceCmd = &cobra.Command{
	Use:   "import [file-path]",
	Short: "Import evidence from structured file (JSON or Markdown/Obsidian)",
	Long:  `Import evidence from a structured file and attach to a finding. Supports JSON (array or single object) or Markdown with Obsidian frontmatter.`,
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		filePath := args[0]
		findingID, _ := cmd.Flags().GetString("finding-id")
		fileType, _ := cmd.Flags().GetString("file-type")

		if findingID == "" {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, "finding-id is required for importing evidence", nil))
			return
		}

		fileData, err := os.ReadFile(filePath)
		if err != nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, fmt.Sprintf("Failed to read file: %v", err), nil))
			return
		}

		var evidenceArray []map[string]interface{}
		switch strings.ToLower(fileType) {
		case "json":
			evidenceArray, err = parseJSONFile(fileData)
		case "markdown", "md", "obsidian":
			evidenceArray, err = parseMarkdownFile(fileData)
		default:
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, fmt.Sprintf("Unsupported file type: %s. Valid options are: json, markdown", fileType), nil))
			return
		}

		if err != nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, fmt.Sprintf("Failed to parse file: %v", err), nil))
			return
		}

		if len(evidenceArray) == 0 {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, "No evidence records found in file", nil))
			return
		}

		clientVersion := shared.GetVersionedApiClient()
		if clientVersion == nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeConfigInvalid, "failed to initialize API client", nil))
			return
		}

		switch client := clientVersion.(type) {
		case *v2_2.Client:
			if client.PentesterOps == nil {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, "PentesterOps is nil for v2.2 client", nil))
				return
			}

			successCount := 0
			failureCount := 0
			for i, evidenceData := range evidenceArray {
				body := mapEvidenceDataToAPI(evidenceData)
				if body["Title"] == nil || body["Title"] == "" {
					shared.LogError("Evidence import: title is required", "index", i+1)
					failureCount++
					continue
				}
				_, err := client.PentesterOps.ApiV22PentesterFindingEvidencePost(findingID, body)
				if err != nil {
					shared.LogError(fmt.Sprintf("Error: failed to create evidence %d", i+1), "error", err)
					failureCount++
					continue
				}
				successCount++
				fmt.Printf("Successfully created evidence %d for finding %s\n", i+1, findingID)
			}
			fmt.Printf("\nImport completed: %d successful, %d failed\n", successCount, failureCount)
		default:
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, fmt.Sprintf("unsupported client type: %T", clientVersion), nil))
			return
		}
	},
}

// mapEvidenceDataToAPI maps evidence data from file to CreateOrEditFindingInstance body.
// Uses PascalCase keys. Ignores fields not in the API structure.
func mapEvidenceDataToAPI(data map[string]interface{}) map[string]interface{} {
	validKeys := map[string]string{
		"title": "Title", "asset": "Asset", "location": "Location", "version": "Version",
		"ip": "Ip", "hostname": "Hostname", "port": "Port", "protocol": "Protocol",
		"issuedetails": "IssueDetails", "issue-details": "IssueDetails", "issue_details": "IssueDetails",
		"reproduce": "Reproduce", "evidence": "Evidence",
		"visibleinreport": "IsVisibleInReport", "visible-in-report": "IsVisibleInReport", "isvisibleinreport": "IsVisibleInReport",
	}
	result := map[string]interface{}{
		"Guid":              "00000000-0000-0000-0000-000000000000",
		"EvidenceFiles":     []interface{}{},
		"NewEvidenceFiles":  []interface{}{},
	}
	for k, v := range data {
		if v == nil {
			continue
		}
		kl := strings.ToLower(strings.ReplaceAll(k, "_", "-"))
		if apiKey, ok := validKeys[kl]; ok {
			switch apiKey {
			case "IsVisibleInReport":
				switch b := v.(type) {
				case bool:
					result[apiKey] = strings.ToLower(fmt.Sprintf("%t", b))
				case string:
					result[apiKey] = strings.ToLower(b)
				default:
					result[apiKey] = "true"
				}
			default:
				result[apiKey] = fmt.Sprintf("%v", v)
			}
		}
	}
	// Defaults
	if _, has := result["IsVisibleInReport"]; !has {
		result["IsVisibleInReport"] = "true"
	}
	return result
}

// Delete finding command
var deleteFindingCmd = &cobra.Command{
	Use:   "delete [finding-id]",
	Short: "Delete a finding (pentester view)",
	Long:  `Delete a finding by its ID using pentester operations.`,
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		findingID := args[0]

		clientVersion := shared.GetVersionedApiClient()
		if clientVersion == nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeConfigInvalid, "failed to initialize API client", nil))
			return
		}

		// Type switch to handle different client versions
		switch client := clientVersion.(type) {
		case *v2_2.Client:
			if client.PentesterOps == nil {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, "PentesterOps is nil for v2.2 client", nil))
				return
			}

			_, err := client.PentesterOps.ApiV22PentesterFindingsByIdDelete(findingID)
			if err != nil {
				shared.LogError("Error: failed to delete finding", "error", err)
				return
			}

			fmt.Printf("Successfully deleted finding %s\n", findingID)

		default:
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, fmt.Sprintf("unsupported client type: %T", clientVersion), nil))
			return
		}
	},
}

// Import findings command
var importFindingsCmd = &cobra.Command{
	Use:   "import [file-path]",
	Short: "Import findings from structured file (JSON or Markdown/Obsidian)",
	Long:  `Import findings from a structured file. Supports JSON files (array or single object) or Markdown files with Obsidian frontmatter.`,
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		filePath := args[0]
		projectID, _ := cmd.Flags().GetString("project-id")
		triggerEvents, _ := cmd.Flags().GetBool("trigger-events")
		fileType, _ := cmd.Flags().GetString("file-type")

		if projectID == "" {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, "project-id is required for importing findings", nil))
			return
		}

		// Read the file
		fileData, err := os.ReadFile(filePath)
		if err != nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, fmt.Sprintf("Failed to read file: %v", err), nil))
			return
		}

		// Parse based on file type
		var findingsArray []map[string]interface{}
		switch strings.ToLower(fileType) {
		case "json":
			findingsArray, err = parseJSONFile(fileData)
		case "markdown", "md", "obsidian":
			findingsArray, err = parseMarkdownFile(fileData)
		default:
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, fmt.Sprintf("Unsupported file type: %s. Valid options are: json, markdown", fileType), nil))
			return
		}

		if err != nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, fmt.Sprintf("Failed to parse file: %v", err), nil))
			return
		}

		if len(findingsArray) == 0 {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeValidationFailed, "No findings found in file", nil))
			return
		}

		clientVersion := shared.GetVersionedApiClient()
		if clientVersion == nil {
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeConfigInvalid, "failed to initialize API client", nil))
			return
		}

		// Type switch to handle different client versions
		switch client := clientVersion.(type) {
		case *v2_2.Client:
			if client.PentesterOps == nil {
				shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, "PentesterOps is nil for v2.2 client", nil))
				return
			}

			successCount := 0
			failureCount := 0

			// Process each finding
			for i, findingData := range findingsArray {
				// Map the finding data to API structure
				findingBody := mapFindingDataToAPI(findingData, projectID)

				// Create the finding
				response, err := client.PentesterOps.ApiV22PentesterFindingsPost(projectID, triggerEvents, findingBody)
				if err != nil {
					shared.LogError(fmt.Sprintf("Error: failed to create finding %d", i+1), "error", err)
					failureCount++
					continue
				}

				successCount++

				// Extract and print finding URL if available
				if response != nil {
					responseBytes, err := json.Marshal(*response)
					if err == nil {
						var guidResponse v2_2.GuidAjaxResponse
						if err := json.Unmarshal(responseBytes, &guidResponse); err == nil {
							if guidResponse.Result != nil && *guidResponse.Result != "" {
								baseURL := viper.GetString("api.base_url")
								if baseURL != "" {
									parsedURL, err := url.Parse(baseURL)
									if err == nil {
										host := parsedURL.Host
										if strings.HasPrefix(host, "api.") {
											host = strings.Replace(host, "api.", "app.", 1)
										}
										findingURL := fmt.Sprintf("%s://%s/App/Projects/Details/%s/Finding/%s",
											parsedURL.Scheme, host, projectID, *guidResponse.Result)
										fmt.Printf("Successfully created finding %d: %s\n", i+1, findingURL)
									}
								}
							}
						}
					}
				}
			}

			fmt.Printf("\nImport completed: %d successful, %d failed\n", successCount, failureCount)

		default:
			shared.HandleError(cmd, errors.NewCyverError(errors.ErrCodeUnexpectedType, fmt.Sprintf("unsupported client type: %T", clientVersion), nil))
			return
		}
	},
}

// mapFindingDataToAPI maps finding data from file to API structure
// Ignores fields not in the API structure
func mapFindingDataToAPI(data map[string]interface{}, projectID string) map[string]interface{} {
	result := make(map[string]interface{})

	// Define valid API fields based on CreateOrUpdateFindingRequest schema
	validFields := map[string]bool{
		"code":                  true,
		"name":                  true,
		"title":                 true, // Alias for name
		"description":           true,
		"type":                  true,
		"status":                true,
		"severity":              true,
		"complianceStatus":      true,
		"complianceComment":     true,
		"impact":                true,
		"impactDescription":     true,
		"likelihood":            true,
		"likelihoodDescription": true,
		"recommendation":        true,
		"backgroundInformation": true,
		"cvss":                  true,
		"projectTaskId":         true,
		"reviewerId":            true,
		"cweList":               true,
		"cveList":               true,
		"mitreAttackTacticsList": true,
		"mitreAttackTechniquesList": true,
		"mitreAttackMitigationsList": true,
		"assetIdList":           true,
		"reoccurrenceIdList":    true,
		"labelIds":              true,
		"labelIdList":           true,
	}

	// Map fields, handling aliases and conversions
	for key, value := range data {
		keyLower := strings.ToLower(key)
		var apiKey string
		var shouldInclude bool

		// Handle field name mappings and aliases
		switch keyLower {
		case "title":
			apiKey = "name"
			shouldInclude = true
		case "name":
			apiKey = "name"
			shouldInclude = true
		case "type":
			apiKey = "type"
			shouldInclude = true
			// Convert type string or number to enum value
			if strVal, ok := value.(string); ok {
				var typeValue int32
				switch strings.ToLower(strVal) {
				case "vulnerability", "1":
					typeValue = 1
				case "nonconformity", "2":
					typeValue = 2
				case "observation", "4":
					typeValue = 4
				case "incident", "8":
					typeValue = 8
				case "risk", "16":
					typeValue = 16
				default:
					// Try to parse as integer
					if intVal, err := strconv.Atoi(strVal); err == nil {
						typeValue = int32(intVal)
					} else {
						continue // Skip invalid type
					}
				}
				value = typeValue
			} else if numVal, ok := value.(float64); ok {
				// JSON numbers are float64
				value = int32(numVal)
			} else if numVal, ok := value.(int); ok {
				value = int32(numVal)
			}
		case "status":
			apiKey = "status"
			shouldInclude = true
			// Convert status string or number to enum value
			if strVal, ok := value.(string); ok {
				statusValue := convertStatusToEnum(strVal)
				value = statusValue
			} else if numVal, ok := value.(float64); ok {
				// JSON numbers are float64
				value = int32(numVal)
			} else if numVal, ok := value.(int); ok {
				value = int32(numVal)
			}
		case "severity":
			apiKey = "severity"
			shouldInclude = true
			// Convert severity string or number to enum value
			if strVal, ok := value.(string); ok {
				severityValue := convertSeverityToEnum(strVal)
				value = severityValue
			} else if numVal, ok := value.(float64); ok {
				// JSON numbers are float64
				value = int32(numVal)
			} else if numVal, ok := value.(int); ok {
				value = int32(numVal)
			}
		default:
			// Check if it's a valid field (case-insensitive)
			found := false
			for validKey := range validFields {
				if strings.ToLower(validKey) == keyLower {
					apiKey = validKey
					shouldInclude = true
					found = true
					break
				}
			}
			if !found {
				// Field not in API structure, ignore it
				continue
			}
		}

		if shouldInclude && value != nil {
			result[apiKey] = value
		}
	}

	// Ensure name is set (required field)
	if _, hasName := result["name"]; !hasName {
		if title, hasTitle := data["title"]; hasTitle {
			result["name"] = title
		}
	}

	return result
}

// convertStatusToEnum converts status string to enum integer value
func convertStatusToEnum(status string) int32 {
	statusLower := strings.ToLower(status)
	switch statusLower {
	case "draft":
		return 1
	case "pendingfix", "pending-fix":
		return 2
	case "fixed":
		return 3
	case "readyretest", "ready-retest":
		return 4
	case "accepted":
		return 5
	case "toreview", "to-review":
		return 6
	case "reviewed":
		return 7
	case "mitigated":
		return 8
	case "partialfix", "partial-fix":
		return 9
	case "falsepositive", "false-positive":
		return 10
	case "raised":
		return 11
	case "reopen", "re-open":
		return 12
	case "acknowledged":
		return 13
	case "identified":
		return 14
	default:
		// Try to parse as integer
		if intVal, err := strconv.Atoi(status); err == nil {
			return int32(intVal)
		}
		// Default to draft
		return 1
	}
}

// convertSeverityToEnum converts severity string to enum integer value
// Severity scale: Info=0, Low=1, Medium=2, High=3, Critical=4
func convertSeverityToEnum(severity string) int32 {
	severityLower := strings.ToLower(severity)
	switch severityLower {
	case "info":
		return 0
	case "low":
		return 1
	case "medium":
		return 2
	case "high":
		return 3
	case "critical":
		return 4
	default:
		// Try to parse as integer
		if intVal, err := strconv.Atoi(severity); err == nil {
			return int32(intVal)
		}
		// Return as-is if it's already a number
		return 0
	}
}

// Initialize function to register all findings commands
func init() {
	// Add flags to list findings command
	listFindingsCmd.Flags().String("project-id", "", "Filter by project ID")
	listFindingsCmd.Flags().String("type", "", "Filter by finding type")
	listFindingsCmd.Flags().String("status", "", "Filter by status")
	listFindingsCmd.Flags().String("severity-list", "", "Filter by severity list")
	listFindingsCmd.Flags().String("vulnerability-type-list", "", "Filter by vulnerability type list")
	listFindingsCmd.Flags().String("id-list", "", "Filter by ID list")
	listFindingsCmd.Flags().String("asset-id-list", "", "Filter by asset ID list")
	listFindingsCmd.Flags().Int("max-results", 10, "Maximum number of results")
	listFindingsCmd.Flags().Int("skip-count", 0, "Number of results to skip")
	listFindingsCmd.Flags().StringP("output", "o", "table", "Output format (json, short, table, custom)")
	listFindingsCmd.Flags().Int("max-columns", 4, "Maximum number of columns for custom table output")

	// Add flags to get finding command
	getFindingCmd.Flags().StringP("output", "o", "table", "Output format (json, table, custom)")
	getFindingCmd.Flags().Int("max-columns", 4, "Maximum number of columns for custom table output")
	getFindingCmd.Flags().Bool("include-evidence", false, "Include evidence in the response")

	// Add flags to create finding command
	createFindingCmd.Flags().String("project-id", "", "Project ID (required)")
	createFindingCmd.Flags().String("title", "", "Finding title (required)")
	createFindingCmd.Flags().String("description", "", "Finding description")
	createFindingCmd.Flags().String("severity", "", "Finding severity (critical, high, medium, low, info)")
	createFindingCmd.Flags().String("status", "draft", "Finding status (default: draft)")
	createFindingCmd.Flags().String("type", "", "Finding type (Vulnerability or Observation)")
	createFindingCmd.Flags().Bool("trigger-events", false, "Trigger events")

	// Add flags to update finding command
	updateFindingCmd.Flags().String("title", "", "Finding title")
	updateFindingCmd.Flags().String("description", "", "Finding description")
	updateFindingCmd.Flags().String("severity", "", "Finding severity")
	updateFindingCmd.Flags().String("status", "", "Finding status")
	updateFindingCmd.Flags().Bool("trigger-events", false, "Trigger events")

	// Add flags to import findings command
	importFindingsCmd.Flags().String("project-id", "", "Project ID (required)")
	importFindingsCmd.Flags().Bool("trigger-events", false, "Trigger events")
	importFindingsCmd.Flags().String("file-type", "json", "File type: json or markdown (default: json)")

	// Add flags to create evidence command
	createEvidenceCmd.Flags().String("finding-id", "", "Finding ID (required)")
	createEvidenceCmd.Flags().String("title", "", "Evidence title (required)")
	createEvidenceCmd.Flags().String("asset", "", "Asset")
	createEvidenceCmd.Flags().String("location", "", "Location")
	createEvidenceCmd.Flags().String("version", "", "Version")
	createEvidenceCmd.Flags().String("ip", "", "IP")
	createEvidenceCmd.Flags().String("hostname", "", "Hostname")
	createEvidenceCmd.Flags().String("port", "", "Port")
	createEvidenceCmd.Flags().String("protocol", "", "Protocol")
	createEvidenceCmd.Flags().String("issue-details", "", "Issue details")
	createEvidenceCmd.Flags().String("reproduce", "", "Reproduce steps")
	createEvidenceCmd.Flags().String("evidence", "", "Evidence content")
	createEvidenceCmd.Flags().Bool("visible-in-report", true, "Include in report (default: true)")

	// Add flags to import evidence command
	importEvidenceCmd.Flags().String("finding-id", "", "Finding ID to attach evidence to (required)")
	importEvidenceCmd.Flags().String("file-type", "json", "File type: json or markdown (default: json)")

	// Evidence command group
	evidenceCmd.AddCommand(createEvidenceCmd)
	evidenceCmd.AddCommand(importEvidenceCmd)

	// Add all commands to the findings command group
	findingsCmd.AddCommand(listFindingsCmd)
	findingsCmd.AddCommand(getFindingCmd)
	findingsCmd.AddCommand(createFindingCmd)
	findingsCmd.AddCommand(updateFindingCmd)
	findingsCmd.AddCommand(deleteFindingCmd)
	findingsCmd.AddCommand(importFindingsCmd)
	findingsCmd.AddCommand(evidenceCmd)

	// Commands will be added to pentester command group via InitPentesterCommands
}

// parseJSONFile parses a JSON file and returns an array of finding objects
func parseJSONFile(fileData []byte) ([]map[string]interface{}, error) {
	var findingsData interface{}
	if err := json.Unmarshal(fileData, &findingsData); err != nil {
		return nil, fmt.Errorf("failed to parse JSON: %v", err)
	}

	// Convert to array format
	var findingsArray []map[string]interface{}
	switch v := findingsData.(type) {
	case []interface{}:
		// Already an array
		for _, item := range v {
			if itemMap, ok := item.(map[string]interface{}); ok {
				findingsArray = append(findingsArray, itemMap)
			}
		}
	case map[string]interface{}:
		// Single object, convert to array
		findingsArray = []map[string]interface{}{v}
	default:
		return nil, fmt.Errorf("JSON must be an object or array of objects")
	}

	return findingsArray, nil
}

// parseMarkdownFile parses a Markdown file with Obsidian frontmatter
// Frontmatter is between '---' delimiters at the start of the file
func parseMarkdownFile(fileData []byte) ([]map[string]interface{}, error) {
	content := string(fileData)
	lines := strings.Split(content, "\n")

	// Find frontmatter boundaries
	startIdx := -1
	endIdx := -1
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "---" {
			if startIdx == -1 {
				startIdx = i + 1 // Start after the first '---'
			} else {
				endIdx = i // End at the second '---'
				break
			}
		}
	}

	if startIdx == -1 || endIdx == -1 {
		return nil, fmt.Errorf("no frontmatter found (expected '---' delimiters)")
	}

	// Extract frontmatter lines
	frontmatterLines := lines[startIdx:endIdx]

	// Parse frontmatter
	result := make(map[string]interface{})
	i := 0
	for i < len(frontmatterLines) {
		line := frontmatterLines[i]
		trimmed := strings.TrimSpace(line)

		// Skip empty lines
		if trimmed == "" {
			i++
			continue
		}

		// Check if this is a list item (starts with '-' and is indented)
		currentIndent := getIndentLevel(line)
		if strings.HasPrefix(trimmed, "-") && currentIndent > 0 {
			// This is a list item - find the parent key
			key := ""
			// Look back to find the key (should be on previous non-empty line ending with ':')
			for j := i - 1; j >= 0; j-- {
				prevLine := frontmatterLines[j]
				prevTrimmed := strings.TrimSpace(prevLine)
				prevIndent := getIndentLevel(prevLine)

				if prevTrimmed != "" && !strings.HasPrefix(prevTrimmed, "-") {
					// Check if this line ends with ':' and has less or equal indentation
					if strings.HasSuffix(prevTrimmed, ":") && prevIndent < currentIndent {
						if idx := strings.Index(prevTrimmed, ":"); idx != -1 {
							key = strings.TrimSpace(prevTrimmed[:idx])
						}
						break
					}
				}
			}

			if key != "" {
				// Collect all list items for this key
				var listItems []string
				baseIndent := currentIndent
				for i < len(frontmatterLines) {
					currentLine := frontmatterLines[i]
					currentTrimmed := strings.TrimSpace(currentLine)
					currentIndent := getIndentLevel(currentLine)

					// Check if this is still part of the list
					if strings.HasPrefix(currentTrimmed, "-") && currentIndent >= baseIndent {
						// Extract the value after '-'
						value := strings.TrimSpace(strings.TrimPrefix(currentTrimmed, "-"))
						// Remove quotes if present
						value = strings.Trim(value, "\"'")
						if value != "" {
							listItems = append(listItems, value)
						}
						i++
					} else if currentIndent < baseIndent {
						// Indentation decreased, list is done
						break
					} else if currentTrimmed == "" {
						// Empty line, might be end of list
						i++
						break
					} else {
						// Not a list item, list is done
						break
					}
				}

				if len(listItems) > 0 {
					result[key] = listItems
				}
				continue
			}
		}

		// Regular key:value pair
		if idx := strings.Index(trimmed, ":"); idx != -1 {
			key := strings.TrimSpace(trimmed[:idx])
			value := strings.TrimSpace(trimmed[idx+1:])
			// Remove quotes if present
			value = strings.Trim(value, "\"'")

			// Check if next line is indented (might be a multi-line value or list)
			if i+1 < len(frontmatterLines) {
				nextLine := frontmatterLines[i+1]
				nextTrimmed := strings.TrimSpace(nextLine)
				nextIndent := getIndentLevel(nextLine)

				// If next line starts with '-', it's a list (handled above)
				if strings.HasPrefix(nextTrimmed, "-") && nextIndent > currentIndent {
					// This will be handled in the next iteration
					result[key] = nil // Placeholder, will be replaced by list
					i++
					continue
				}

				// If next line is more indented and doesn't start with '-', it's a continuation
				if nextIndent > currentIndent && !strings.HasPrefix(nextTrimmed, "-") && nextTrimmed != "" {
					// Collect multi-line value
					var multiLineValue []string
					if value != "" {
						multiLineValue = append(multiLineValue, value)
					}
					i++
					for i < len(frontmatterLines) {
						contLine := frontmatterLines[i]
						contTrimmed := strings.TrimSpace(contLine)
						contIndent := getIndentLevel(contLine)

						if contIndent > currentIndent && contTrimmed != "" && !strings.HasPrefix(contTrimmed, "-") {
							multiLineValue = append(multiLineValue, contTrimmed)
							i++
						} else {
							break
						}
					}
					if len(multiLineValue) > 0 {
						result[key] = strings.Join(multiLineValue, " ")
					}
					continue
				}
			}

			// Single value
			if value != "" {
				result[key] = value
			}
		}

		i++
	}

	// Return as array with single item
	return []map[string]interface{}{result}, nil
}

// getIndentLevel returns the number of leading spaces/tabs
func getIndentLevel(line string) int {
	indent := 0
	for _, char := range line {
		if char == ' ' {
			indent++
		} else if char == '\t' {
			indent += 4 // Treat tab as 4 spaces
		} else {
			break
		}
	}
	return indent
}
